#!/bin/env bash
set -o errexit -o nounset -o pipefail

if [[ -t 1 ]]; then
    TITLE=$(printf "\e[97;1;4m") # White, bold, underline
    ALIASES=$(printf "\e[90m") # Grey
    RESET=$(printf "\e[0m")
else
    TITLE=''
    ALIASES=''
    RESET=''
fi

# Helper to handle critical errors
fail() {
    echo "$exe: $1" >&2
    exit "${2-246}"
}

bug() {
    fail "BUG: $1"
}

# Helper to output debug data when using the bin/tdd script (development only)
debug() {
    local lines="${BASH_LINENO[*]}"
    lines=${lines% 0}
    echo "[line ${lines// /, }]" "$@" >&3
}

# Parse any parameters
action=''
exact=''
exe=${0##*/}
error=''

set_action() {
    if [[ -n $action ]]; then
        set_error "The '--$action' and '--$1' arguments are incompatible"
    fi

    action=$1
}

set_error() {
    if [[ -n $error ]]; then
        error=$1
    fi
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --completion)
            set_action completion
            shift
            ;;
        --exact)
            exact=true
            shift
            ;;
        --exe)
            exe=$2
            shift 2
            ;;
        --prefix)
            exact=false
            shift
            ;;
        --print)
            set_action print
            shift
            ;;
        --)
            shift
            break
            ;;
        --*)
            fail "Invalid option '$1'"
            ;;
        *) break ;;
    esac
done

if [[ -n $error ]]; then
    fail "$error"
fi

# Completion script
if [[ $action = 'completion' ]]; then
    if [[ $exe = 'bin' ]]; then
        echo '_bin() { TODO; }' # TODO
        echo 'complete -F _bin bin'
    else
        echo "_bin_$exe() { TODO; }" # TODO
        echo "complete -F _bin_$exe $exe"
    fi
    exit
fi

# Helper to search parent directories
findup() (
    while ! test "$@"; do
        if [[ $PWD = '/' ]]; then
            return 1
        fi
        cd ..
    done
    echo "$PWD"
)

# Look for a .binconfig file
binconfig=''
if root=$(findup -f .binconfig); then
    binconfig="$root/.binconfig"
fi

# Aliases
aliases=()
declare -A alias_to_command
declare -A alias_sources

register_alias() {
    local alias=$1
    local command=$2
    local source=$3

    if [[ -n ${alias_to_command[$alias]-} ]]; then
        fail "The alias '$alias' conflicts with an existing alias in $source (originally defined in ${alias_sources[$alias]})"
    fi

    aliases+=("$alias")
    alias_to_command[$alias]=$command
    alias_sources[$alias]=$source
}

# Parse .binconfig
bin_dirname='bin'

declare -A help

if [[ -n $binconfig ]]; then
    command=''

    line=0
    while IFS='=' read -r key value; do
        (( line+=1 ))

        if [[ $key = '' || $key = '#'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            command=${BASH_REMATCH[1]}
        elif [[ -z $command && $key = 'dir' ]]; then
            # dir=scripts
            bin_dirname=$value
        elif [[ -z $command && $key = 'exact' && -z $exact ]]; then
            # exact=true
            exact=$value
        elif [[ -n $command && ( $key = 'alias' || $key = 'aliases' ) ]]; then
            # alias=blah
            # aliases=blah1, blah2
            IFS=',' read -ra line_aliases <<< "$value"
            for alias in "${line_aliases[@]}"; do
                alias=${alias// }
                register_alias "$alias" "$command" "$binconfig line $line"
            done
        elif [[ -n $command && $key = 'help' ]]; then
            # help=Description
            help[$command]=$value
        fi
    done < "$binconfig"
fi

if [[ -z $exact ]]; then
    exact=false
fi

# Locate the bin/ directory
if [[ -n $binconfig ]]; then
    bin_directory="$root/$bin_dirname"
elif root=$(findup -d bin); then
    bin_directory="$root/bin"
else
    fail "'bin' directory not found" 127
fi

# Find all the commands available
commands=()
non_executable_files=()

declare -A command_to_executable

find_commands() {
    local directory=$1
    local prefix=${2-}

    local file
    local name

    # Loop through the directory to find commands
    for file in "$directory/"*; do
        if [[ ! -e $file ]]; then
            continue
        fi

        name=${file##*/} # Remove path

        if [[ $name == _* ]]; then
            : # Files starting with "_"
        elif [[ -d $file ]]; then
            if [[ $bin_dirname != '.' ]]; then
                find_commands "$file" "$prefix$name "
            fi
        elif [[ ! -x $file ]]; then
            non_executable_files+=("$file")
        elif [[ "$name" == *' '* ]]; then
            # Spaces in the name
            commands+=("$prefix'$name'")
            command_to_executable["$prefix'$name'"]=$file
        else
            commands+=("$prefix$name")
            command_to_executable["$prefix$name"]=$file
        fi
    done
}

find_commands "$bin_directory"

# Process aliases
for alias in "${aliases[@]}"; do
    # Check for conflicts
    if [[ -n "${command_to_executable[$alias]-}" ]]; then
        fail "The alias '$alias' conflicts with an existing command in ${alias_sources[$alias]}"
    fi

    # Expand aliases to cover subcommands (e.g. if 'deploy'='push' then 'deploy live'='push live')
    target=${alias_to_command[$alias]}
    for command in "${commands[@]}"; do
        if [[ "$command" = "$target "* ]]; then
            suffix=${command:${#target}}
            aliases+=("$alias$suffix")
            alias_to_command[$alias$suffix]="$target$suffix"
        fi
    done
done

# Helpers to find matching commands
in_array() {
    local needle=$1
    shift

    for value in "$@"; do
        if [[ "$value" = "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

matches() {
    local type=$1
    local target=$2
    local command=$3

    if [[ $type = exact ]]; then
        [[ "$command" = "$target" ]]
    elif [[ $type = with-extension ]]; then
        [[ "$command" = "$target".* ]]
    elif [[ $type = prefix ]]; then
        [[ "$command" = "$target"* ]]
    else
        bug "Invalid \$type '$type' passed to matches()"
    fi
}

matching_commands=()

find_matching_commands() {
    local type=$1
    local target=$2

    local -A commands_matching_aliases
    local command

    for alias in "${aliases[@]}"; do
        if matches "$type" "$target" "$alias"; then
            command=${alias_to_command[$alias]}
            commands_matching_aliases[$command]=true
        fi
    done

    matching_commands=()
    for command in "${commands[@]}"; do
        if ${commands_matching_aliases[$command]-false} || matches "$type" "$target" "$command"; then
            matching_commands+=("$command")
        fi
    done
}

matching_commands_shared_prefix() {
    local prefix=$1
    local prefix_length=${#prefix}

    local shared_next_command=''

    for command in "${matching_commands[@]}"; do
        # Remove the common prefix
        local remaining=${command:$prefix_length}

        if [[ ! $remaining = *' '* ]]; then
            continue
        fi

        local next_command=${remaining/ *}

        if [[ -z $shared_next_command ]]; then
            shared_next_command=$next_command
        elif [[ "$next_command" != "$shared_next_command" ]]; then
            # Not unique
            return 1
        fi
    done

    if [[ -n $shared_next_command ]]; then
        echo "$prefix$shared_next_command"
    else
        # No subcommands found
        return 1
    fi
}

# By default we will list all available commands
list_title='Available commands'
list_commands=("${commands[@]}")

# Loop through each argument until we find a matching command
run_command_if_only_one_match() {
    if [[ ${#matching_commands[@]} -eq 1 ]]; then
        command=${matching_commands[0]}
        executable=${command_to_executable[$command]}
        exec "$executable" "$@"
    fi
}

entered_command=''

while [[ $# -gt 0 ]]; do
    command=$1
    shift

    # Build up the entered command in canonical format
    if [[ $command = *' '* ]]; then
        entered_command+=" '$command'"
    else
        entered_command+=" $command"
    fi

    # Check if there's an exact match
    find_matching_commands exact "${entered_command:1}"

    run_command_if_only_one_match "$@"

    # Check if there's an almost-exact match with an added extension
    find_matching_commands with-extension "${entered_command:1}"

    run_command_if_only_one_match "$@"

    # Check if there are any subcommands
    find_matching_commands prefix "${entered_command:1} "

    if [[ ${#matching_commands[@]} -gt 0 ]]; then
        list_title='Available subcommands'
        list_commands=("${matching_commands[@]}")
        continue
    fi

    # Check if there are any prefix matches
    find_matching_commands prefix "${entered_command:1}"

    if parent=$(matching_commands_shared_prefix "${entered_command:1}"); then
        entered_command=" $parent"
        list_title='Available subcommands'
        list_commands=("${matching_commands[@]}")
        continue
    fi

    if ! $exact; then
        run_command_if_only_one_match "$@"
    fi

    # If there were no prefix matches, stop searching
    if [[ ${#matching_commands[@]} -eq 0 ]]; then
        fail "Command \"${entered_command:1}\" not found in $bin_directory" 127
    fi

    # Otherwise display the list of matches
    list_title='Matching commands'
    list_commands=("${matching_commands[@]}")
    break
done

# Remove the extensions, as long as they are unique
remove_extension() {
    # Can't use ${command%%.*} because it could remove too much ("a.b c" => "a" instead of "a.b")
    # Can't use ${command%.*} because it could remove too little ("a.b.c" => "a.b" instead of "a")
    local command="$1"

    while [[ "$command" =~ (.*?)(\.[a-zA-Z0-9]+)+ ]]; do
        command=${BASH_REMATCH[1]}
    done

    echo "$command"
}

has_duplicate() {
    local short=$1
    local long=$2

    local command

    for command in "${commands[@]}"; do
        case "$command" in
            # Ignore a match to itself
            "$long") continue ;;
            # Matched to the short command, but not the long one
            "$short") return 0 ;;
            "$short."*) return 0 ;;
        esac
    done

    for alias in "${aliases[@]}"; do
        case "$alias" in
            "$short") return 0 ;;
            "$short."*) return 0 ;;
        esac
    done

    # No matches found
    return 1
}

unique_commands=()

for command in "${list_commands[@]}"; do
    short=$(remove_extension "$command")
    if has_duplicate "$short" "$command"; then
        unique_commands+=("$command")
    else
        unique_commands+=("$short")
    fi
done

# Calculate the maximum length of a command in the list so we can align the help text
maxlength=0
for command in "${unique_commands[@]}"; do
    if [[ ${#command} -gt $maxlength ]]; then
        maxlength=${#command}
    fi
done

# Output the list
get_command_aliases() {
    local command=$1
    local command_aliases=''
    local command_alias_count=0

    for alias in "${aliases[@]}"; do
        local target=${alias_to_command[$alias]}
        if [[ "$target" = "$command" ]]; then
            (( command_alias_count+=1 ))
            command_aliases+=", $alias"
        fi
    done

    if [[ $command_alias_count -eq 1 ]]; then
        echo "alias: ${command_aliases:2}"
    elif [[ $command_alias_count -gt 1 ]]; then
        echo "aliases: ${command_aliases:2}"
    fi
}

echo "$TITLE$list_title$RESET"

for command in "${unique_commands[@]}"; do
    command_help=${help[$command]-}
    command_aliases=$(get_command_aliases "$command")

    if [[ -n $command_help && -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help $ALIASES($command_aliases)$RESET"
    elif [[ -n $command_help ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help"
    elif [[ -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$ALIASES($command_aliases)$RESET"
    else
        printf "%s %s\n" "$exe" "$command"
    fi
done

# List non-executable files, if any
if [[ ${#non_executable_files[@]} -gt 0 ]]; then
    echo
    echo "Not executable:"
    for file in "${non_executable_files[@]}"; do
        echo "$file"
    done
fi
