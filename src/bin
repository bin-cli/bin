#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail
shopt -s nullglob

################################################################################
# Bin - A simple task runner        Copyright (c) 2023 Dave James Miller       #
# https://bin-cli.com/              MIT License                                #
################################################################################

#===============================================================================
# Constants
#===============================================================================

# Version (set by build script - don't change in source file)
VERSION='1.2.3-source'

# The BIN_TEST_ROOT env var is ignored in production builds, but is used to emulate global directories in the tests
if [[ $VERSION = '1.2.3-dev' ]]; then
    BIN_TEST_ROOT=${BIN_TEST_ROOT-}
else
    BIN_TEST_ROOT='' # kcov-ignore-line: Not tested
fi

# ANSI codes
if [[ -t 1 ]]; then
    # kcov-ignore-start: There is never a terminal connected during unit tests
    RESET=$'\e[0m'
    BOLD=$'\e[1m'
    UNDERLINE=$'\e[4m'
    YELLOW=$'\e[33m'
    GREY=$'\e[90m'
    LWHITE=$'\e[97m'
    # kcov-ignore-end
else
    RESET=''
    BOLD=''
    UNDERLINE=''
    YELLOW=''
    GREY=''
    LWHITE=''
fi

# The debug output always goes to a terminal, but indirectly
DEBUG_GREY=$'\e[90m'
DEBUG_RESET=$'\e[0m'

# Exit codes
ERR_NOT_EXECUTABLE=126
ERR_NOT_FOUND=127
ERR_GENERIC=246

#===============================================================================
# General helpers
#===============================================================================

in_array() {
    local needle=$1
    shift

    local value

    for value in "$@"; do
        if [[ "$value" = "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

# This is to support Bash 3 (macOS - *sigh*!), which doesn't have associative arrays
map_key() {
    local key=$1

    local i
    local length="${#key}"
    for ((i = 0; i < length; i++)); do
        local char="${key:i:1}"
        case $char in
            [a-zA-Z0-9]) printf '%s' "$char" ;;
            # Encode all other characters in hex to make them valid variable names
            *) printf '_%02X' "'$char" ;;
        esac
    done
}

map_set() {
    local name=$1
    local key=$2
    local value=$3

    # Make an array containing the raw keys
    eval "$name+=(\"\$key\")"

    # Store the values in separate variables
    printf -v "map__${name}__$(map_key "$2")" %s "$value"
}

map_get() {
    local name=$1
    local key=$2
    local default=${3-}

    key="map__${name}__$(map_key "$key")"

    echo "${!key-$default}"
}

map_clear() {
    local name=$1

    eval "unset \"\${!map__${name}__@}\""
    eval "$name=()"
}

#===============================================================================
# Cross-platform `realpath`
#===============================================================================

# Source: https://github.com/mkropat/sh-realpath/blob/65512368b8155b176b67122aa395ac580d9acc5b/realpath.sh

# kcov-ignore-start: Not our code to test, and not every code path is covered by our tests
realpath() {
    canonicalize_path "$(resolve_symlinks "$1")"
}

resolve_symlinks() {
    _resolve_symlinks "$1"
}

_resolve_symlinks() {
    _assert_no_path_cycles "$@" || return

    local dir_context path
    path=$(readlink -- "$1")
    # shellcheck disable=SC2181
    if [ $? -eq 0 ]; then
        dir_context=$(dirname -- "$1")
        _resolve_symlinks "$(_prepend_dir_context_if_necessary "$dir_context" "$path")" "$@"
    else
        printf '%s\n' "$1"
    fi
}

_prepend_dir_context_if_necessary() {
    if [ "$1" = . ]; then
        printf '%s\n' "$2"
    else
        _prepend_path_if_relative "$1" "$2"
    fi
}

_prepend_path_if_relative() {
    case "$2" in
        /* ) printf '%s\n' "$2" ;;
         * ) printf '%s\n' "$1/$2" ;;
    esac
}

_assert_no_path_cycles() {
    local target path

    target=$1
    shift

    for path in "$@"; do
        if [ "$path" = "$target" ]; then
            return 1
        fi
    done
}

canonicalize_path() {
    if [ -d "$1" ]; then
        _canonicalize_dir_path "$1"
    else
        _canonicalize_file_path "$1"
    fi
}

_canonicalize_dir_path() {
    (cd "$1" 2>/dev/null && pwd -P)
}

_canonicalize_file_path() {
    local dir file
    dir=$(dirname -- "$1")
    file=$(basename -- "$1")
    (cd "$dir" 2>/dev/null && printf '%s/%s\n' "$(pwd -P)" "$file")
}
# kcov-ignore-end

#===============================================================================
# Output helpers
#===============================================================================

# So we can use 'debug' inside functions where stdout is redirected,
# redirect FD4 to stdout globally, then write debug data to FD4 locally
exec 4>&1

# If FD3 is open, write debug data to it
fd3_open=false
if { true >&3; } 2>/dev/null; then # kcov-ignore-line: Usage not detected
    fd3_open=true
fi

debug() {
    # Display debug data when using --debug (only after parsing parameters)
    if ${debug-false}; then
        echo "$@" >&4
    fi

    # Output debug data to FD 3 when using the 'bin tdd' script in development
    if $fd3_open; then
        local lines="${BASH_LINENO[*]}"
        lines=${lines% 0}
        echo "$@" "${DEBUG_GREY}[line ${lines// /, }]${DEBUG_RESET}" >&3
    fi
}

debug_exit() {
    debug "$@"
    if ${debug-false}; then
        exit
    fi
}

fail() {
    local message=$1
    local code=${2-$ERR_GENERIC}

    debug "Failed with message: $message"
    debug_exit "Exit code: $code"

    if [[ $action = 'complete-bash' ]]; then
        exit
    fi

    echo "$exe: $message" >&2
    exit "$code"
}

bug() {
    # kcov-ignore-start: This should never be needed!
    local lines="${BASH_LINENO[*]}"
    lines=${lines% 0}
    fail "BUG: $1 on line ${lines// /, }"
    # kcov-ignore-end
}

#===============================================================================
# Parse parameters
#===============================================================================

help() {
    echo "Usage: bin [OPTIONS] [--] [COMMAND] [ARGUMENTS...]"
    echo
    echo "Options that can be used with a command:"
    echo "  --dir DIR             Specify the directory name to search for (overrides .binconfig)"
    echo "  --exact               Disable unique prefix matching"
    echo "  --exe NAME            Override the executable name displayed in the command list"
    echo "  --fallback COMMAND    If the command is not found, run the given global command (implies '--exact')"
    echo "  --prefix              Enable unique prefix matching (overrides .binconfig)"
    echo "  --shim                If the command is not found, run the global command with the same name (implies '--exact')"
    echo
    echo "Options that do something with a COMMAND:"
    echo "  --create, -c          Create the given script and open in your \$EDITOR (implies '--exact')"
    echo "  --edit, -e            Open the given script in your \$EDITOR"
    echo "  --print               Output the command that would have been run, instead of running it"
    echo "  --debug               Display debugging information instead of running the command"
    echo
    echo "Options that do something special and don't accept a COMMAND:"
    echo "  --completion          Output a tab completion script for the current shell"
    echo "  --shell SHELL         Override the shell to use for '--completion' -- only 'bash' is currently supported"
    echo "  --help, -h            Display this help"
    echo "  --version, -v         Display the current version number and exit"
    echo
    echo "Any options must be given before the command, because everything after the command will be passed as parameters to the script."
}

action=''
bin_dirname=''
debug=false
exact=''
exe=${0##*/}
error=''
fallback=''
shim=false

set_action() {
    if [[ -n $action ]]; then
        set_error "The '--$action' and '--$1' arguments are incompatible"
    fi

    action=$1
}

set_error() {
    # Don't exit immediately because '--exe' may come after the parameter with the error
    # But only display the first error encountered, as if we had exited immediately
    if [[ -z $error ]]; then
        error=$1
    fi
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --complete-bash)
            set_action complete-bash
            shift
            ;;
        --completion)
            set_action completion
            shift
            ;;
        --create | -c)
            set_action create
            shift
            ;;
        --debug)
            debug=true
            shift
            ;;
        --dir)
            bin_dirname=$2
            shift 2
            ;;
        --edit | -e)
            set_action edit
            shift
            ;;
        --exact)
            exact=true
            shift
            ;;
        --exe)
            exe=$2
            shift 2
            ;;
        --fallback)
            fallback=$2
            shift 2
            ;;
        --help | -h)
            set_action help
            shift
            ;;
        --prefix)
            exact=false
            shift
            ;;
        --print)
            set_action print
            shift
            ;;
        --shim)
            shim=true
            shift
            ;;
        --version | -v)
            set_action version
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            fail "Invalid option '$1'"
            ;;
        *)
            break
            ;;
    esac
done

if [[ -n $error ]]; then
    fail "$error"
fi

if [[ -z $action ]]; then
    action='run'
fi

#===============================================================================
# Display help / version information
#===============================================================================

debug "Bin version $VERSION"
debug "Action set to '$action'"

if [[ $action = 'help' ]]; then
    debug_exit 'Would output help text'
    help
    exit
fi

if [[ $action = 'version' ]]; then
    debug_exit "Would print version number"
    echo "Bin version $VERSION"
    exit
fi

#===============================================================================
# Tab completion script generator
#===============================================================================

if [[ $action = 'completion' ]]; then
    complete_command=("$0" --complete-bash)
    if [[ -n $bin_dirname ]]; then
        complete_command+=("--dir" "'$bin_dirname'")
    fi
    if [[ $exe != 'bin' ]]; then
        complete_command+=("--exe" "'$exe'")
    fi
    echo "complete -C \"${complete_command[*]}\" -o default $exe"
    exit
fi

#===============================================================================
# Alias helpers
#===============================================================================

aliases=()
alias_to_executable=()

register_command_alias() {
    local alias=$1
    local command=$2
    local source=$3

    if [[ -n $(map_get alias_sources "$alias") ]]; then
        fail "The alias '$alias' defined in $source conflicts with the alias defined in $(map_get alias_sources "$alias")"
    fi

    aliases+=("$alias")
    map_set alias_to_command "$alias" "$command"
    map_set alias_sources "$alias" "$source"

    debug "---- Registered alias '$alias' for command '$command'"
}

register_executable_alias() {
    local alias=$1
    local executable=$2
    local source=$3

    if [[ -n $(map_get alias_sources "$alias") ]]; then
        fail "The alias '$alias' defined in $source conflicts with the alias defined in $(map_get alias_sources "$alias")"
    fi

    aliases+=("$alias")
    map_set alias_to_executable "$alias" "$executable"
    map_set alias_sources "$alias" "$source"

    debug "-- Registered alias '$alias' for executable '$executable'"
}

process_aliases() {
    # Match symlink aliases with their commands
    debug "Processing symlink aliases"

    local alias
    local executable
    local target
    local command

    # This long-winded syntax (used here and in various other places) is to make it work in Bash 3 (macOS)
    # https://stackoverflow.com/a/61551944/167815
    for alias in ${alias_to_executable+"${alias_to_executable[@]}"}; do
        executable=$(map_get alias_to_executable "$alias")
        if [[ -n $executable ]]; then
            command=$(map_get executable_to_command "$executable")
            map_set alias_to_command "$alias" "$command"
            debug "-- Registered alias '$alias' for executable '$executable' to command '$command'"
        fi
    done

    debug "Processing directory aliases and checking for conflicts"

    for alias in ${aliases+"${aliases[@]}"}; do
        # Check for conflicts
        executable=$(map_get command_to_executable "$alias")
        if [[ -n $executable ]]; then
            fail "The alias '$alias' defined in $(map_get alias_sources "$alias") conflicts with an existing command"
        fi

        # Expand aliases to cover subcommands (e.g. if 'deploy'='push' then 'deploy live'='push live')
        target=$(map_get alias_to_command "$alias")
        for command in ${commands+"${commands[@]}"}; do
            if [[ "$command" = "$target "* ]]; then
                local suffix=${command:${#target}}
                aliases+=("$alias$suffix")
                map_set alias_to_command "$alias$suffix" "$target$suffix"
                debug "---- Registered alias '$alias$suffix' for command '$target$suffix'"
            fi
        done
    done
}

#===============================================================================
# Directory search helper
#===============================================================================

findup() (
    while true; do
        if test "$@"; then
            debug "-- $PWD - found"
            echo "$PWD"
            return 0
        else
            debug "-- $PWD - not found"
        fi

        if [[ $PWD = '/' || $PWD = "$BIN_TEST_ROOT" ]]; then
            return 1
        fi

        cd ..

    done
)

#===============================================================================
# Locate config file
#===============================================================================

binconfig=''

debug "Working directory is $PWD"

# Initial search & parse to find the dir= setting only
# That way we don't need to "undo" everything we did if it doesn't match
debug "Looking for a .binconfig file in:"

if root=$(findup -f .binconfig); then
    binconfig="$root/.binconfig"
    bin_dirname_from_config=''

    debug "Checking $binconfig for a 'dir' setting"

    line=0
    while IFS='=' read -r key value; do
        ((line += 1))

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            debug "-- Reached section $key - giving up"
            break
        elif [[ $key = 'dir' ]]; then
            # dir=scripts
            debug "-- Found $key=$value"
            bin_dirname_from_config=$value
            break
        fi
    done <"$binconfig" # kcov-ignore-line: Usage not detected

    if [[ -z $bin_dirname_from_config ]]; then
        debug "-- Not found"
    fi

    # Sanity checks
    if [[ $bin_dirname_from_config = /* ]]; then
        fail "The option 'dir' cannot be an absolute path in $binconfig line $line"
    fi

    bin_dir_real=$(realpath "$root/$bin_dirname_from_config") || true
    root_real=$(realpath "$root") || true
    if [[ "$bin_dir_real/" != "$root_real/"* ]]; then
        debug "-- bin_dir_real=$bin_dir_real"
        debug "-- root_real=$root_real"
        fail "The option 'dir' cannot point to a directory outside $root in $binconfig line $line"
    fi

    if [[ -z $bin_dirname ]]; then
        # If no directory was given at the command line, use the one from the config file
        debug "-- Using '$bin_dirname_from_config' from the config file"
        bin_dirname=$bin_dirname_from_config
    elif [[ "$bin_dirname_from_config" != "$bin_dirname" ]]; then
        # If the directory given at the command line doesn't match the config file,
        # ignore the rest of the config file, and don't treat this as the root
        debug "-- The config file setting '$bin_dirname_from_config' doesn't match the CLI setting '$bin_dirname' - ignoring config file"
        binconfig=''
    fi
fi

#===============================================================================
# Parse config file
#===============================================================================

commands_listed_in_config=()

if [[ -n $binconfig ]]; then
    debug "Parsing $binconfig"

    command=''

    line=0
    while IFS='=' read -r key value; do
        ((line += 1))

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            command=${BASH_REMATCH[1]}
            debug "-- Found [$command] section"
            commands_listed_in_config+=("$command")
        elif [[ -z $command && $key = 'dir' ]]; then
            # Already handled
            :
        elif [[ -z $command && $key = 'exact' ]]; then
            # exact=true
            if [[ -z $exact ]]; then
                # Can't use ${value,,} because it doesn't work in Bash 3 (macOS)
                if in_array "$(echo "$value" | tr '[:upper:]' '[:lower:]')" 'false' 'no' 'off' '0'; then
                    exact=false
                else
                    exact=true
                fi
                debug "-- Set 'exact' to $exact"
            else
                debug "-- Ignoring 'exact=$value' because it has already been set (in the CLI or config file)"
            fi
        elif [[ -z $command ]]; then
            # Unknown keys don't trigger an error for forwards compatibility (global)
            debug "---- Unknown key '$key'"
        elif [[ ($key = 'alias' || $key = 'aliases') ]]; then
            # alias=blah
            # aliases=blah1, blah2
            IFS=',' read -ra line_aliases <<<"$value"
            for alias in ${line_aliases+"${line_aliases[@]}"}; do
                alias=${alias## }
                alias=${alias%% }
                register_command_alias "$alias" "$command" "$binconfig line $line"
            done
        elif [[ $key = 'help' ]]; then
            # help=Description
            map_set help "$command" "$value"
            debug "---- Registered help for '$command'"
        else
            # Unknown keys don't trigger an error for forwards compatibility (command)
            debug "---- Unknown key '$key'"
        fi
    done <"$binconfig" # kcov-ignore-line: Usage not detected
fi

# Default values, if not given at the command line or in the config file
if [[ -z $bin_dirname ]]; then
    bin_dirname=bin
    debug "'dir' defaulted to '$bin_dirname'"
fi

if [[ -z $exact ]]; then
    exact=false
    debug "'exact' defaulted to '$exact'"
fi

#===============================================================================
# Locate the bin/ directory
#===============================================================================

is_root_dir=false

if [[ -n $binconfig ]]; then

    # If a .binconfig file exists, that takes precedence
    if [[ ${bin_dirname%%/} = '.' ]]; then
        # Special case for the root directory (see docs)
        bin_directory=$root
        is_root_dir=true
        debug "Bin directory set to '$bin_directory' (root) from config file"
    else
        bin_directory="${root%%/}/$bin_dirname"
        debug "Bin directory set to '$bin_directory' from config file"
    fi

    if [[ ! -d $bin_directory ]]; then
        fail "Found '$binconfig', but '$bin_directory/' directory is missing"
    fi

elif [[ $bin_dirname = '/'* ]]; then

    # Absolute path given at the command line
    bin_directory="$bin_dirname"
    debug "Bin directory set to '$bin_directory' (absolute) from CLI"

    if [[ ! -d $bin_directory ]]; then
        fail "Specified directory '$bin_directory/' is missing"
    fi

else

    # If there is no .binconfig, look for a bin/ directory instead (or other name specified with --dir)
    debug "Looking for a $bin_dirname/ directory in:"
    if root=$(findup -d "$bin_dirname"); then
        bin_directory="${root%%/}/$bin_dirname"
        debug "Bin directory set to '$bin_directory'"
    else
        fail "Could not find '$bin_dirname/' directory or '.binconfig' file starting from '$PWD'" $ERR_NOT_FOUND
    fi

    # Check for special cases that we only allow with a matching .binconfig file
    if in_array "$bin_directory" "$BIN_TEST_ROOT/bin" "$BIN_TEST_ROOT/usr/bin" "$BIN_TEST_ROOT/usr/local/bin" "$BIN_TEST_ROOT/snap/bin" "$HOME/bin"; then
        fail "Could not find '$bin_dirname/' directory or '.binconfig' file starting from '$PWD' (ignored '$bin_directory')" $ERR_NOT_FOUND
    fi

fi

#===============================================================================
# Find and register available commands
#===============================================================================

commands=()
broken_symlinks=()
non_executable_files=()

register_commands() {
    local directory=$1
    local prefix=${2-}

    # Loop through the directory to find commands
    local file

    for file in "$directory/"*; do
        local name
        name=${file##*/}  # Remove path
        name=${name// /-} # Spaces to dashes

        local realfile
        realfile=$(realpath "$file") || true

        if [[ -L $file ]]; then
            local target
            target=$(readlink "$file")
            if [[ $target = /* ]]; then
                fail "The symlink '$file' must use a relative path, not absolute ('$target')"
            fi
            if [[ -e $file ]]; then
                register_executable_alias "$prefix$name" "$realfile" "$file"
            else
                debug "-- Skipped broken symlink '$file' => '$target'"
                broken_symlinks+=("$file => $target")
            fi
        elif [[ -d $file ]]; then
            # Ignore subdirectories if scripts are in the root directory,
            # because it could take a long time to search a large tree, and it's
            # unlikely someone who keeps scripts in the root would also have
            # some in subdirectories
            if $is_root_dir; then
                debug "-- Ignored subdirectory '$file'"
            else
                debug "-- Registered subdirectory '$file' to parent command '$prefix$name'"
                map_set executable_to_command "$realfile" "$prefix$name"
                debug "-- Searching subdirectory '$file'"
                register_commands "$file" "$prefix$name "
            fi
        elif [[ ! -x $file ]]; then
            if ! $is_root_dir; then
                non_executable_files+=("$file")
            fi
            debug "-- Ignored non-executable file '$file'"
        else
            commands+=("$prefix$name")
            map_set command_to_executable "$prefix$name" "$realfile"
            map_set executable_to_command "$realfile" "$prefix$name"
            debug "-- Registered command '$prefix$name' for executable '$realfile'"
        fi
    done
}

debug "Searching '$bin_directory' for scripts"
register_commands "$bin_directory"

process_aliases

#===============================================================================
# Helpers to match input to commands
#===============================================================================

command_matches() {
    local type=$1
    local target=$2
    local command=$3

    # Check for a match of the given type
    if [[ $type = exact ]]; then
        [[ "$command" = "$target" ]]
    elif [[ $type = with-extension ]]; then
        [[ "$command" = "$target".* ]]
    elif [[ $type = subcommands ]]; then
        [[ "$command" = "$target "* ]]
    elif [[ $type = prefix ]]; then
        [[ "$command" = "$target"* ]]
    else
        bug "Invalid \$type '$type' passed to command_matches()" # kcov-ignore-line: This should never be happen
    fi

    # If it doesn't match, return false
    # shellcheck disable=SC2181
    if [[ $? -gt 0 ]]; then
        debug "---- No match for '$command'"
        return 1
    fi

    return 0
}

is_hidden_command() {
    local command=$1
    local target=${2-}

    # We can't just match on $command, because it may be the parent command that
    # has already been typed that is hidden, so subcommands should be shown
    local prefix_length=${#target}

    if [[ $prefix_length -eq 0 ]]; then
        command=" $command"
    else
        command="${command:$prefix_length}"
    fi

    [[ $command = *' _'* ]]
}

matching_commands=()

find_matching_commands() {
    local type=$1
    local target=$2

    debug "-- Looking for command '$target' ($type)"

    map_clear commands_matching_aliases

    local alias
    for alias in ${aliases+"${aliases[@]}"}; do
        if command_matches "$type" "$target" "$alias"; then
            command=$(map_get alias_to_command "$alias")
            map_set commands_matching_aliases "$command" true
            debug "---- Found matching alias '$alias' for command '$command'"
        fi
    done

    matching_commands=()
    local command
    for command in ${commands+"${commands[@]}"}; do
        # shellcheck disable=SC2091
        if $(map_get commands_matching_aliases "$command" false); then
            debug "---- Found matching command '$command' (from alias)"
            matching_commands+=("$command")
        elif command_matches "$type" "$target" "$command"; then
            debug "---- Found matching command '$command'"
            matching_commands+=("$command")
        fi
    done
}

matching_commands_shared_prefix() {
    local prefix=$1
    local prefix_length=${#prefix}

    local shared_next_command=''

    local command
    for command in ${matching_commands+"${matching_commands[@]}"}; do
        # Remove the common prefix
        local remaining=${command:$prefix_length}

        if [[ ! $remaining = *' '* ]]; then
            continue
        fi

        local next_command=${remaining/ */}

        if [[ -z $shared_next_command ]]; then
            shared_next_command=$next_command
        elif [[ "$next_command" != "$shared_next_command" ]]; then
            # Not unique
            return 1
        fi
    done

    if [[ -n $shared_next_command ]]; then
        echo "$prefix$shared_next_command"
    else
        # No subcommands found
        return 1
    fi
}

#===============================================================================
# Tab completion setup
#===============================================================================

last_parameter=0

if [[ $action = 'complete-bash' ]]; then
    debug "Tab completion setup:"
    debug "-- COMP_LINE='$COMP_LINE'"
    debug "-- COMP_POINT=$COMP_POINT"

    # Remove everything after the cursor and assign to numbered variables
    args=${COMP_LINE:0:$COMP_POINT}
    debug "-- Setting parameters to '$args'"
    # shellcheck disable=SC2086
    set -- $args

    # Remove the command name
    debug "-- Removing the first parameter '$1'"
    shift

    # If there is a space at the end, we want to complete the next parameter; otherwise the last one given
    if [[ $args != *' ' ]]; then
        last_parameter=1
    fi
fi

#===============================================================================
# Parse parameters and run the command
#===============================================================================

open_in_editor() {
    local file=$1

    local editor=${VISUAL-${EDITOR-}}

    if [[ -z $editor ]]; then
        if command -v editor &>/dev/null; then
            editor='editor'
        elif command -v nano &>/dev/null; then
            editor='nano'
        elif command -v vi &>/dev/null; then
            editor='vi'
        else
            fail 'No editor configured - please export EDITOR or VISUAL environment variables'
        fi
    fi

    debug_exit "Would execute:" "$editor" "$file"
    exec "$editor" "$file"
}

run_command() {
    if [[ $action = 'complete-bash' ]]; then
        bug "run_command() should not be reached during tab completion" # kcov-ignore-line: This should never be happen
    elif [[ $action = 'create' ]]; then
        fail "$1 already exists (use --edit to edit it)"
    elif [[ $action = 'edit' ]]; then
        open_in_editor "$1"
    elif [[ $action = 'print' ]]; then
        debug_exit "Would print:" "$@"
        echo "$@"
        exit
    else
        debug_exit "Would execute:" "$@"
        exec "$@"
    fi
}

run_command_if_only_one_match() {
    if [[ ${#matching_commands[@]} -eq 1 ]]; then
        local command=${matching_commands[0]}
        local executable
        executable=$(map_get command_to_executable "$command")
        export BIN_COMMAND="$exe $command"
        run_command "$executable" "$@"
    else
        debug "---- There were ${#matching_commands[@]} matches - not running command"
    fi
}

# If no command is given, we will list all available commands
list_title='Available commands'
list_commands=(${commands+"${commands[@]}"})

# Loop through each argument until we find a matching command
debug "Processing positional parameters"
current_directory=$bin_directory
full_command=''

while [[ $# -gt $last_parameter ]]; do
    subcommand=$1
    shift

    # Build up the entered command in canonical format
    full_command+=" $subcommand"

    # Check if there's an exact match - run it if so
    find_matching_commands exact "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there's an almost-exact match with an added extension - run it if so
    find_matching_commands with-extension "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there are any subcommands - move on to the next argument if so
    find_matching_commands subcommands "${full_command:1}"

    if [[ ${#matching_commands[@]} -gt 0 ]]; then
        current_directory="$current_directory/$subcommand"
        list_title='Available subcommands'
        list_commands=(${matching_commands+"${matching_commands[@]}"})
        continue
    fi

    # No exact matches - check for special actions
    if [[ $action = 'create' ]]; then
        debug "No command found - creating it"

        if [[ $subcommand = .* ]]; then
            fail "Command names may not start with '.'"
        fi

        if [[ $# -gt 0 ]]; then
            current_directory="$current_directory/$subcommand"
            mkdir "$current_directory"
            echo "Created subdirectory $current_directory/"
            continue
        fi

        script="$current_directory/$subcommand"
        echo -e "#!/usr/bin/env bash\nset -eno pipefail\n\n" >"$script"
        chmod +x "$script"
        echo "Created script $script"
        open_in_editor "$script"
    elif $shim; then
        debug "No command found - using shim"
        # We want word splitting here
        # shellcheck disable=SC2086
        run_command ${full_command:1} "$@"
    elif [[ -n $fallback ]]; then
        debug "No command found - using fallback"
        # We want word splitting here - the fallback command may contain spaces to separate arguments
        # shellcheck disable=SC2086
        run_command $fallback "$@"
    fi

    # Check if there are any prefix matches
    # We need to check even with --exact so we can list them
    find_matching_commands prefix "${full_command:1}"

    if ! $exact && parent=$(matching_commands_shared_prefix "${full_command:1}"); then
        # If all matching commands have the same parent command, pretend
        # the user typed the full parent command, then continue parsing
        debug "-- Expanding partial match to '$parent'"
        current_directory="$current_directory/$parent"
        full_command=" $parent"
        list_title='Matching commands'
        list_commands=(${matching_commands+"${matching_commands[@]}"})
        continue
    fi

    if $exact; then
        debug "---- Not running match (if any) because 'exact' is $exact"
    else
        run_command_if_only_one_match "$@"
    fi

    # If there were no prefix matches, stop searching
    if [[ ${#matching_commands[@]} -eq 0 ]]; then
        if $is_root_dir && [[ -d "$current_directory/$subcommand" ]]; then
            fail "Subcommands are not supported with the config option 'dir=$bin_dirname'"
        fi
        if [[ $subcommand = .* && -e "$current_directory/$subcommand" ]]; then
            fail "Command names may not start with '.'"
        fi
        if [[ -f "$current_directory/$subcommand" && ! -x "$current_directory/$subcommand" ]]; then
            fail "'$current_directory/$subcommand' is not executable (chmod +x)" $ERR_NOT_EXECUTABLE
        fi
        fail "Command '${full_command:1}' not found in $bin_directory" $ERR_NOT_FOUND
    fi

    # Otherwise display the list of matches
    list_title='Matching commands'
    list_commands=(${matching_commands+"${matching_commands[@]}"})
    break
done

#===============================================================================
# Determine unique command names
#===============================================================================

remove_extension() {
    # Can't use ${command%%.*} because it could remove too much ("a.b c" => "a" instead of "a.b")
    # Can't use ${command%.*} because it could remove too little ("a.b.c" => "a.b" instead of "a")
    local command="$1"

    while [[ "$command" =~ (.*)(\.[a-zA-Z0-9]+)+ ]]; do
        command=${BASH_REMATCH[1]}
    done

    echo "$command"
}

has_duplicate() {
    local short=$1
    local long=$2

    local command
    for command in ${commands+"${commands[@]}"}; do
        case "$command" in
            # Ignore a match to itself
            "$long") continue ;;
            # Matched to the short command, but not the long one
            "$short") return 0 ;;
            "$short."*) return 0 ;;
            "$short "*) return 0 ;;
        esac
    done

    local alias
    for alias in ${aliases+"${aliases[@]}"}; do
        case "$alias" in
            "$short") return 0 ;;
            "$short "*) return 0 ;;
        esac
    done

    # No matches found
    return 1
}

debug "Determining unique command names for listing"
unique_commands=()

for command in ${list_commands+"${list_commands[@]}"}; do
    executable=$(map_get command_to_executable "$command")
    if $is_root_dir && [[ $executable =~ \.(json|md|txt|yaml|yml)$ ]]; then
        debug "-- Ignored common non-executable file type '$executable' in root directory"
        continue
    fi

    short=$(remove_extension "$command")

    if [[ "$short" = "$command" ]]; then
        debug "-- '$command' can't be shortened"
        unique_commands+=("$command")
    elif has_duplicate "$short" "$command"; then
        debug "-- '$short' is not unique - using full command name '$command'"
        unique_commands+=("$command")
    else
        debug "-- '$command' shortened to '$short'"
        unique_commands+=("$short")
    fi
done

#===============================================================================
# Tab completion output
#===============================================================================

if [[ $action = 'complete-bash' ]]; then

    # Work out the full prefix we're looking for
    prefix=''
    if [[ -n $full_command ]]; then
        prefix="${full_command:1} "
    fi

    target="$prefix${1-}"

    debug "Looking for commands and aliases starting with '$target'"

    # Look for commands and aliases that match, and collect the first parameter for each
    matches=()
    matching_commands=()

    for command in ${unique_commands+"${unique_commands[@]}"}; do
        if ! command_matches prefix "$target" "$command"; then
            continue
        fi

        match=${command#"$prefix"}
        match=${match/ */}
        matches+=("$match")
        matching_commands+=("$command")
        debug "-- Found matching command '$command' => '$match'"
    done

    for alias in ${aliases+"${aliases[@]}"}; do
        if ! command_matches prefix "$target" "$alias"; then
            continue
        fi

        command=$(map_get alias_to_command "$alias")
        if in_array "$command" ${matching_commands+"${matching_commands[@]}"}; then
            debug "-- Skipping matching alias '$alias' because the command '$command' has already matched"
        else
            match=${alias#"$prefix"}
            match=${match/ */}
            matches+=("$match")
            matching_commands+=("$command")
            debug "-- Found matching alias '$alias' => '$match' (command='$command')"
        fi
    done

    # Output the matches and remove duplicates
    for command in ${matches+"${matches[@]}"}; do
        if is_hidden_command "$command" "${1-}"; then
            debug "-- '$command' is hidden - skipping"
            continue
        fi

        echo "$command"
    done | sort | uniq

    exit

fi

#===============================================================================
# List available/matching commands
#===============================================================================

# Remove hidden commands
visible_commands=()

for command in ${unique_commands+"${unique_commands[@]}"}; do
    if is_hidden_command "$command" "${full_command:1}"; then
        debug "-- '$command' is hidden - skipping"
    else
        visible_commands+=("$command")
    fi
done

# Calculate the maximum length of a command in the list so we can align the help text
maxlength=0
for command in ${visible_commands+"${visible_commands[@]}"}; do
    if [[ ${#command} -gt $maxlength ]]; then
        maxlength=${#command}
    fi
done

debug "Maximum matching command length is $maxlength"

# Output the list
get_command_aliases() {
    local command=$1
    local command_aliases=''
    local command_alias_count=0

    local alias
    for alias in ${aliases+"${aliases[@]}"}; do
        local target
        target=$(map_get alias_to_command "$alias")
        if [[ "$target" = "$command" ]]; then
            ((command_alias_count += 1))
            command_aliases+=", $alias"
        fi
    done

    if [[ $command_alias_count -eq 1 ]]; then
        echo "alias: ${command_aliases:2}"
    elif [[ $command_alias_count -gt 1 ]]; then
        echo "aliases: ${command_aliases:2}"
    fi
}

debug_exit "Would list ${#visible_commands[@]} matching command(s)"

echo "$LWHITE$BOLD$UNDERLINE$list_title$RESET"

for command in ${visible_commands+"${visible_commands[@]}"}; do
    command_help=$(map_get help "$command")
    command_aliases=$(get_command_aliases "$command")

    if [[ -n $command_help && -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help $GREY($command_aliases)$RESET"
    elif [[ -n $command_help ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help"
    elif [[ -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$GREY($command_aliases)$RESET"
    else
        printf "%s %s\n" "$exe" "$command"
    fi
done

if [[ ${#visible_commands[@]} -eq 0 ]]; then
    echo "${GREY}None found${RESET}"
fi

#===============================================================================
# Display warnings
#===============================================================================

# Broken symlinks
if [[ ${#broken_symlinks[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following symlinks point to targets that don't exist:${RESET}"
    for symlink in ${broken_symlinks+"${broken_symlinks[@]}"}; do
        echo "$symlink"
    done
fi

# Non-executable files
if [[ ${#non_executable_files[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following files are not executable (chmod +x):${RESET}"
    for file in ${non_executable_files+"${non_executable_files[@]}"}; do
        echo "$file"
    done
fi

# Missing commands in .binconfig
missing_commands=()
for command in ${commands_listed_in_config+"${commands_listed_in_config[@]}"}; do
    executable=$(map_get command_to_executable "$command")
    if [[ -z $executable ]]; then
        missing_commands+=("$command")
    fi
done

if [[ ${#missing_commands[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following commands listed in $binconfig do not exist:${RESET}"
    for command in ${missing_commands+"${missing_commands[@]}"}; do
        echo "[$command]"
    done
fi
